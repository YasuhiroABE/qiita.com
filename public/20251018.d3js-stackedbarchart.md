---
title: D3.jsを使って少し複雑なバーチャートを表示してみる
tags:
  - JavaScript
  - d3.js
private: false
updated_at: '2025-10-20T09:37:42+09:00'
id: 3fae0333f5aac6159bb6
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに

アンケートを[sdaps](https://sdaps.org/)で実施していて、集計したCSVデータを元に結果を可視化するためにWebサイトを作成しました。

D3 Galleryにある[Stacked Bar Chart](https://observablehq.com/@d3/stacked-bar-chart)は、データを割合で表示する、例えば5段階スケールなどの順序尺度の、データを表示するには便利です。

順序尺度の場合には平均値のような数値処理はあまり意味がなく、中央値のようなデータの分布を確認する可視化手法が適しています。

その点で箱ひげ図などよりは、Stacked Bar Chartが便利そうです。

今回は単純な積み上げではなく、2020年から2025年までといった時系列でグラフを並べたいと思っています。

同じ項目の結果を年毎に並べるには、Stacked Bar Chartに[Grouped Bar Chart](https://observablehq.com/@d3/grouped-bar-chart)を組み合わせれば出来そうです。

その結果、次のような結果を表示させたので、その顛末を残しておきます。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/78296/e18d051c-1531-4673-9e6c-e2bcfa1700f0.png)

このグラフは"1-1-0", "1-2-0"の2つの系列について、2023年〜2025年の変化を全体で100%になるような各要素の積み上げグラフで表示する例です。

# サンプルコード

完全に動作するサンプルはGitHubに置いています。

* [https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart)

主要なファイルは次の場所に格納されています。

* [content/data.json](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart/blob/5a9d825cd39f6c2414536bd3d6af00ca09480ddd/content/data.json) - グラフの元データ
* [layouts/_default/list.html](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart/blob/5a9d825cd39f6c2414536bd3d6af00ca09480ddd/layouts/_default/list.html) - data.jsonを処理し、StackedRatioBarChart()を呼び出すJavaScriptコード本体が記述されたファイル
* [static/js/stacked_ordinal_ratio.js](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart/blob/5a9d825cd39f6c2414536bd3d6af00ca09480ddd/static/js/stacked_ordinal_ratio.js) - グラフを描画する関数(StackedRatioBarChart)を格納したファイル

このサンプルは[https://github.com/YasuhiroABE/hugo-i18nsite-template](https://github.com/YasuhiroABE/hugo-i18nsite-template)を元にしています。I18N関連のコードについての[説明はこちら](https://qiita.com/YasuhiroABE/items/2b1f844b34f9ed04c9fb)を参考にしてください。

## サンプルコードの実行

前提としてhugoとasciidoctorがインストールされていることが前提です。

hugoは [https://github.com/gohugoio/hugo/releases/](https://github.com/gohugoio/hugo/releases/) から最新版をダウンロードして、/usr/local/bin/などにhugoコマンドを配置してください。

asciidoctorはUbuntuであればパッケージで導入できます。

```bash:
$ sudo apt install asciidoctor
```

準備ができたら次の要領で実行します。

```bash:基本的な使い方
$ git clone https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart.git
$ cd hugo-d3js-stackedbarchart
$ make up
$ make up
```

# 環境

開発環境はUbuntu 24.04です。

また次のようにD3 v7を利用しています。

```html:
<script src="https://d3js.org/d3.v7.min.js"></script>
```

現在の最新バージョンは、v7.9.0です。

* [d3/d3 Releases on GitHub](https://github.com/d3/d3/releases)

## サンプルデータ

今回準備したのは次のようなJSON形式のデータになっています。

```text:
[
    {
    "id":"1-1-0",
    "stack_id":"1-1-0-1",
    "year":"AY2023",
    "total":10,
    "answers":1,
    "selection":"1"
    },
    ...
]
```

各要素は概ね次のような用途になっています。

* id: グループ名
* stack_id: 積み上げる要素名
* year: stack_idが所属するサブグループ名
* total: 全体数
* answers: 要素数
* selection: 任意のラベル文字列

データ全体で(id, year, stack_id)がユニークになっています。

(answers / total)を計算する事によって割合を求め、全体が100%になる積み上げグラフを表示しています。

# オリジナル Stacked Bar Chart関数の構造

元の[Stacked Bar Chart](https://observablehq.com/@d3/stacked-bar-chart)は現在ではObsolete扱いになっていますが、元々この関数を利用していたので、コードベースはこちらになっています。

これはデータをx,y,zの各系列として受け取っていて、その要素数が全て同じであることを利用し、配列の添え字(0,1,2,...)を利用しています。

積み上げグラフの作成には``d3.stack()``を利用して、Y座標を"0"から順番に加えて合計で"1"になるようなデータの系列を出力します。

## オリジナルコードの課題

d3.stack()は積み上げる対象を識別して適切にゼロリセットが行われます。

これをネストしたデータに適用するとゼロリセットが適切に行われず、グラフが適切に描画されません。

そのため複数のd3.stack()オブジェクトを準備する必要があります。

# 改造した Stacked Bar Chart関数の構造

今回の例ではx系列を年度毎の時系列まとめるため、この系列を"xz"系列として定義しています。

* x系列 - アンケートの場合は質問番号に該当 (e.g., [ "1-3-0", "1-3-1", ...])
* y系列 - 割合を示す 0〜1 の数値 (今回は 回答数 / 全体数 を有効数字2桁)
* z系列 - アンケートの場合は回答番号に相当 (e.g., [ "1-3-0-0", "1-3-0-1", "1-3-0-2",...]
* xz系列 - アンケートの回答年 (e.g., [ "FY2023", "FY2024", "FY2025" ])

このx系列名をキーとして、``d3.stack()`` を生成しています。

今回は"1-1-0"と"1-2-0"に対応した2つのd3.stack()オブジェクトを作成しています。

```javascript:
    let new_series_gens = {}; // store multiple series generators for each x value
    Object.entries(zDomainMap).forEach(function([x_key, z_values]) {
        new_series_gens[x_key] = d3.stack()
            .keys(z_values)
            .value(function([x, I], z) {
                return Y[I.get(z)]; // return the percentage value for a specific z value
            })
            .order(order)
            .offset(offset);
    });
```

``x_key``には"1-3-0"のようなx系列が入り、``z_values``には対応するz系列("1-3-0-1", "1-3-0-2", etc)が入ります。

それぞれのz系列に対応するデータに対応する割合(0.0〜1.0)を積み上げた結果を返すジェネレーターが作成されます。

後はグラフを作成する時にX軸方向に移動するための``xzScale``を使って``xzPadding``で指定した量だけずらすといったコードを加えた程度です。

また``zDomainMap``というデータ構造を作成して渡すようにしています。

これはz系列に含まれる各アンケートの回答番号が、どのx系列のキーに含まれるかを示しています。

* xzDomainMapの構造 - { "1-3-0": ["1-3-0-1", "1-3-0-2", ..., "1-3-0-5"], "1-3-1": [...] }

この他の部分はほぼオリジナルのStacked Bar Chartを踏襲しているので、難しい部分はないかと思います。

# さいごに

サンプルコードを確認してもらうのがベストだと思いますが、Stacked Bar Chartが扱えれば難しくないとは思います。

ただ自分で改造する時には、``console.log()``などでデータ構造を確認しながら進める必要がありました。

最近のサンプルは、抽象度の高い[Plot](https://observablehq.com/plot/)ライブラリを利用するように変更されています。

Plotで十分表現できなくなった時にObsolete扱いになっている旧コードの構造は参考になると思います。

こういったライブラリは間隔尺度や比例尺度の量的データの可視化を中心に構成されている印象です。

順序尺度のような質的データの表現では少し違った表現力が欲しくなる場面が増えるのかもしれません。
