---
title: D3.jsを使って少し複雑なバーチャートを表示してみる
tags:
  - JavaScript
  - d3.js
private: false
updated_at: '2025-10-21T10:46:28+09:00'
id: 3fae0333f5aac6159bb6
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに

アンケートを[sdaps](https://sdaps.org/)で実施していて、集計したCSVデータを元に結果を可視化するためにWebサイトを作成しました。

D3 Galleryにある[Stacked Bar Chart](https://observablehq.com/@d3/stacked-bar-chart)は、データを割合で表示する、例えば5段階スケールなどの順序尺度のような、データを表示するには便利です。

!["Stacked Bar Chartの例"](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/78296/7c35f5c8-4e4b-48cd-a689-ed9d923e711a.png "Stacked Bar Chartの例")

順序尺度の場合には平均値のような数値処理はあまり意味がなく、中央値のようなデータの分布を確認する可視化手法が適しています。

その点で箱ひげ図などよりは、Stacked Bar Chartが便利そうです。

今回は単純な積み上げではなく、2020年から2025年までといった時系列でグラフを並べたいと思っています。

同じ項目の結果を年毎に並べるには、Stacked Bar Chartに[Grouped Bar Chart](https://observablehq.com/@d3/grouped-bar-chart)を組み合わせれば出来そうです。

!["Grouped Bar Chartの例"](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/78296/e77e5320-0c21-4819-82df-49e9d4c392ab.png "Grouped Bar Chartの例")

ただ既存のD3のサイトに掲載されている描画例では、これらを組み合わせたグラフの描画は難しかったので、Stacked Bar Chartのコードを改造することにしました。

最終的に次のような結果を表示させることができた、その顛末を残しておきます。

!["作成したネストしたデータの描画例"](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/78296/6191d8be-978f-4051-bacd-2554949a666c.png "作成したネストしたデータの描画例")

このグラフは"CA", "TX"の2つのデータについて、2023年〜2025年の変化を全体で100%になるようなデータ(CA-1〜CA-3, TX-1〜TX-5)の積み上げグラフで表示した例です。

:::note
本来はCA、TXの要素数は同じはずですが、数が同一でなくても動作することを示す例として、要素の数は3つまでと5つまでのデータを描画しています。
:::

今回は積み上げるデータをZ系列、X系列の中でさらにネストしてX軸方向に描画する年度データをXZ系列として定義しています。(後述)

# サンプルコード

完全に動作するサンプルはGitHubに置いています。これを動かしてみてもらうのが一番早いかなと思います。

* [https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart)

主要なファイルは次の場所に格納されています。

* [content/data.json](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart/blob/5a9d825cd39f6c2414536bd3d6af00ca09480ddd/content/data.json) - グラフの元データ (実用途ではCSV形式から変換して生成)
* [layouts/_default/list.html](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart/blob/5a9d825cd39f6c2414536bd3d6af00ca09480ddd/layouts/_default/list.html) - content/data.jsonを処理し、StackedRatioBarChart()を呼び出すJavaScriptコード本体が記述されたファイル
* [static/js/stacked_ordinal_ratio.js](https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart/blob/5a9d825cd39f6c2414536bd3d6af00ca09480ddd/static/js/stacked_ordinal_ratio.js) - グラフを描画する関数(StackedRatioBarChart)を格納したファイル

このサンプルは[https://github.com/YasuhiroABE/hugo-i18nsite-template](https://github.com/YasuhiroABE/hugo-i18nsite-template)を元にしています。I18N関連のコードについての説明は[こちらのQiitaの別記事](https://qiita.com/YasuhiroABE/items/2b1f844b34f9ed04c9fb)を参考にしてください。

## サンプルコードの実行

前提としてhugoがインストールされていることが前提です。

hugoは [https://github.com/gohugoio/hugo/releases/](https://github.com/gohugoio/hugo/releases/) から最新版をダウンロードして、/usr/local/bin/などにhugoコマンドを配置してください。

準備ができたら次の要領で実行します。

```bash:基本的な使い方
$ git clone https://github.com/YasuhiroABE/hugo-d3js-stackedbarchart.git
$ cd hugo-d3js-stackedbarchart
$ make up
$ make firefox
```

最後の部分は環境に依ると思うので、``http://localhost:1313/`` が一般的なhugo previewのデフォルトURLになります。

# 環境

開発環境はUbuntu 24.04です。

またJavaScriptライブラリは次のようにD3 v7を利用しているため、インターネットアクセスが必要です。

```html:
<script src="https://d3js.org/d3.v7.min.js"></script>
```

現在の最新バージョンは、v7.9.0です。

* [d3/d3 Releases on GitHub](https://github.com/d3/d3/releases)

またHugoは``v0.151.2``で確認していますが、特別な機能は利用していないので比較的最近リリースされたものであれば動作すると思います。

## サンプルデータ

今回準備したのは次のようなJSON形式のデータになっています。

```text:
[
    {
        "id":"CA",
        "stack_id":"CA-1",
        "year":"AY2023",
        "total":10,
        "answers":1,
        "selection":"1"
    },
    ...
    {
        "id":"TX",
        "stack_id":"TX-1",
        "year":"AY2023",
        "total":10,
        "answers":1,
        "selection":"1"
    }
]
```

各要素は概ね次のような用途になっています。

* id: グループ名
* stack_id: 積み上げる要素名
* year: stack_idが所属するサブグループ名
* total: 全体数
* answers: 要素数
* selection: 任意のラベル文字列

データ全体で(id, year, stack_id)がユニークになっています。

(answers / total)を計算する事によって割合を求め、全体が100%になる積み上げグラフを表示しています。

# オリジナル Stacked Bar Chart関数の構造

元の[Stacked Bar Chart](https://observablehq.com/@d3/stacked-bar-chart)は現在ではObsolete扱いになっていますが、元々この関数を利用していたので、コードベースはこちらになっています。

これはデータをx,y,zの各系列として受け取っていて、その要素数が全て同じであることを利用し、配列の添え字(0,1,2,...)だけを格納した``I``配列を中心にプログラミングされています。

積み上げグラフの作成には``d3.stack()``を利用して、Y座標を"0"から順番に加えて合計で"1"になるようなデータの系列を出力します。

積み上げグラフを描画する際には``d3.stack()``の利用が現実的なので、これを利用するためにコードを改造することにします。

## オリジナルコードの課題

本来のd3.stack()は積み上げる対象を識別して適切にゼロリセットが行われます。

これをネスト(X系列に対応したXZ系列に対して描画を指示するなど)したデータに適用するとY軸原点へのゼロリセットが適切に行われず、2つめのTX系列のグラフが100%を起点として描画されるため上に突き抜けてしまいます。

そのため今回はCA, TXなどの各X系列毎に、d3.stack()オブジェクトを準備しました。

# 改造した Stacked Bar Chart関数の構造

今回の例ではx系列を年度毎の時系列まとめるため、この系列を"xz"系列として定義しています。

* x系列 - アンケートの場合は質問番号に該当 (e.g., [ "CA", "TX", ...])
* y系列 - 割合を示す 0〜1 の数値 (今回は ``回答数 / 全体数 を有効数字2桁`` で計算させた数値)
* z系列 - アンケートの場合は回答番号に相当 (e.g., [ "CA-0", "CA-1", "CA-2",...]
* xz系列 - アンケートの回答年 (e.g., [ "FY2023", "FY2024", "FY2025" ])

このx系列名をキーとして、``d3.stack()`` を生成しています。

今回は"1-1-0"と"1-2-0"に対応した2つのd3.stack()オブジェクトを作成しています。

```javascript:
    let new_series_gens = {}; // store multiple series generators for each x value
    Object.entries(zDomainMap).forEach(function([x_key, z_values]) {
        new_series_gens[x_key] = d3.stack()
            .keys(z_values)
            .value(function([x, I], z) {
                return Y[I.get(z)]; // return the percentage value for a specific z value
            })
            .order(order)
            .offset(offset);
    });
```

``x_key``には"CA"のようなx系列が入り、``z_values``には対応するz系列("CA-1", "CA-2", etc)が入ります。

それぞれのz系列に対応するデータに対応する割合(0.0〜1.0)を積み上げた結果を返すジェネレーターが作成されます。

後はグラフを作成する時にX軸方向に移動するための``xzScale``を使って``xzPadding``で指定した量だけずらすといったコードを加えた程度です。

これらの処理をさせるために、``zDomainMap``というデータ構造を作成して渡しています。

これはz系列に含まれる各アンケートの回答番号が、どのx系列のキーに含まれるかを示しています。

* xzDomainMapの構造 - { "CA": ["CA-1", "CA-2", ..., "CA-5"], "TX": [...] }

この他の部分はほぼオリジナルのStacked Bar Chartを踏襲しているので、難しい部分はないかと思います。

# さいごに

サンプルコードを確認してもらうのがベストだと思いますが、Stacked Bar Chartが扱えれば難しくないとは思います。

ただ自分で改造する時には、``console.log()``などでデータ構造を確認しながら進める必要がありました。

最近のD3サイトのサンプルは、抽象度の高い[Plot](https://observablehq.com/plot/)ライブラリを利用するように変更されています。

Plotで十分表現できなくなった時にPlot本体を改造するのは難易度が高すぎるので、Obsolete扱いになっている個別グラフの旧コードの構造は参考になると思います。

よく使われるデータは間隔尺度や比例尺度の量的データが中心になるでしょうから、Plotライブラリなどでの可視化もそこを中心に構成されている印象です。

順序尺度のような質的データの表現では少し違った表現力が欲しくなる場面があるかもしれませんので、そのような用途での参考になれば幸いです。
